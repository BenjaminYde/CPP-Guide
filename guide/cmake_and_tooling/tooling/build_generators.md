# Toolchains, Build Systems, and Build Generators

## Key Definitions

### Toolchain

A **toolchain** is a set of tools used to transform source code into an executable or library. It typically includes:

- **Compiler**: Translates source code into object files (e.g., GCC, Clang).
- **Linker**: Combines object files into an executable or library.
- **Other Tools**: May include debuggers, profilers, and formatters.

### Build System

A **build system** is responsible for executing the steps required to build a project, such as invoking compilers and linkers in the correct order based on defined dependencies. It uses configuration files to orchestrate the process.

**Examples**:

- **Make**: Processes `Makefiles` to build software.
- **Ninja**: Processes `build.ninja` files for fast and efficient builds.
- **MSBuild**: Microsoft's build system for Visual Studio projects.
- **Bazel**: Google's build system.

### Build Generator

A **build generator** creates the configuration files that a build system consumes. It acts as an intermediary, translating high-level build logic into platform-specific files.

**Examples**:

- **CMake**: Reads `CMakeLists.txt` and generates files for various build systems, such as `Makefiles` or `build.ninja`.
- **Meson**: Generates files for Ninja.
- **Autotools**: Generates `Makefiles`.

## The Relationship Between Build Generators and Build Systems

1. **CMake** is a **build generator**. It doesn’t directly build your project; instead, it generates configuration files (like `Makefiles` for Make or `build.ninja` for Ninja) based on your project’s `CMakeLists.txt`.

2. **Ninja** and **Make** are **build systems**. They execute the build process by reading the files generated by tools like CMake.

So, a **build generator** (e.g., CMake) produces files that a **build system** (e.g., Ninja or Make) consumes to perform the actual build.

## CMake Generators

CMake supports multiple build system generators. The **default generator** depends on the platform and CMake's configuration during installation.

### Common CMake Generators

- **Unix Makefiles** (default on most Unix-like systems): Generates `Makefiles` for use with Make.
- **Ninja**: Generates `build.ninja` files for Ninja, focusing on speed and minimal rebuilds.
- **Visual Studio Generators**: Generates `.vcxproj` files for Visual Studio versions.
- **Xcode**: Generates project files for macOS's Xcode IDE.

## About Build Systems

### Ninja

- **Purpose**: Ninja is a small, fast build system that focuses on incremental builds, designed to build only the files that have changed. It does not parse or manage dependencies itself but it relies entirely on pre-generated dependency rules provided in the `build.ninja` file.
- **Key Features**:
  - **Speed**: Extremely fast due to its minimalism and allows to execute parallel execution of build rules.
  - **Simplicity**: It doesn’t handle complex logic, focusing purely on execution as specified by the build files.
  - **Integration with Generators**: Typically used with tools like CMake, which generate Ninja-compatible build files.

#### Why Ninja is Popular

- **Performance**: Builds are quicker compared to traditional tools like Make, especially in large projects.
- **Adoption**: Widely supported and integrated into modern build systems like CMake, Meson, and Bazel.
- **Modern Design**: Handles parallel builds effectively, making it suitable for multi-core systems.

### GNU Make

- **What It Is**: GNU Make is a build system that automates the compilation and linking of source code by reading a Makefile, which specifies rules, dependencies, and commands to build targets.
**Standalone Tool**:
  - Make is entirely independent and does not rely on Ninja or other systems. It predates Ninja and is one of the earliest widely-used build tools.
  - Unlike Ninja, Make does everything by itself (parsing, dependency management, and execution), without requiring another tool to generate build files. Ninja relies on pre-generated build files (usually generated by other tools like CMake or Meson) to know what to build and how.
**Key Features**:
  - **Simple Dependency Management**: Tracks file modifications to decide what needs rebuilding.
  - **Customizable Rules**: Allows users to define their build process.
  - **Cross-Platform**: Works on many operating systems.
- **Limitations of Make**:
  - **Manual Setup**: Dependency management is not automatic; developers need to specify rules and dependencies explicitly.
  - **Slow with Large Projects**: Parsing and execution become inefficient in large, complex projects.
  - **No Native Parallelism**: Parallel builds (make -j) are possible but not as optimized as Ninja.

### Bazel

- **Purpose**: Bazel is a high-level, fast, and scalable build and test system created by Google, designed for large-scale, multi-language projects. It focuses on reproducible builds, dependency management, and cross-platform support.

#### Key Features:

- **High-Level Build System**: 
  - Manages dependencies and defines complex build rules.
  - Supports multiple programming languages (e.g., C++, Python, Java, Go, etc.).
- **Reproducible Builds**:
  - Ensures that builds are deterministic and consistent across different environments.
  - Uses a content-based hashing mechanism to track changes in source files and dependencies.
- **Incremental Builds**:
  - Only rebuilds files affected by changes, thanks to its fine-grained dependency tracking.
- **Distributed Builds**:
  - Supports remote execution and caching, making it ideal for distributed teams and large-scale projects.
- **Cross-Platform**:
  - Works seamlessly on different platforms, including Windows, macOS, and Linux.
- **Built-in Testing Framework:**
  - Allows integration and unit testing as part of the build process.

#### Comparison with Ninja

- Bazel is a high-level build system, while Ninja is a low-level build executor.
- Bazel generates and manages dependencies, while Ninja executes pre-generated build rules.
- Bazel can handle end-to-end build and test workflows, while Ninja focuses purely on executing builds efficiently.

#### When to Use Bazel

  - Suitable for large, multi-language projects with complex dependencies.
  - Ideal for monorepos with shared codebases.
  - When you need reproducible, distributed builds and robust dependency management.

## Other Relevant Topics

### Unity Build

- **What It Is**: A method where multiple source files are combined into one or a few large files, compiled together. This reduces the number of individual compilations and accelerates the overall build process.
- **How It Works**: Instead of treating each .cpp file as a separate compilation unit, a unity build aggregates several .cpp files into a single file, then compiles that file. This avoids redundant parsing of header files across multiple translation units.
- **Advantages**:
  - Reduces redundant work during compilation (e.g., parsing headers multiple times).
  - Improves build times for large projects.
- **Disadvantages**:
  - **Harder to trace errors**: When a compilation error occurs, it points to the aggregated file rather than the original source file.
  - **Increased coupling**: Code from different files may inadvertently affect each other during compilation.
  - **Not suitable for all projects**: Especially ones with high modularity or isolated translation units.

### Incremental Builds

- **What It Is**: A technique where only the changed parts of a project are rebuilt instead of rebuilding everything. This is achieved by tracking dependencies between files and only recompiling what's necessary.
- **How It Works**: Tools like Make or Ninja keep track of dependencies via timestamps or hashes. When a file changes, only the dependent files are rebuilt.
- **Advantages**:
  - Saves time in large projects with many files.
  - Reduces the developer's wait time during iterative development.
- **Tools that can do this**:
  - **Ninja**: Very efficient at tracking and rebuilding only what's needed.
  - **Make**: Provides incremental builds but can be slower due to less efficient dependency tracking.

### Cross-Compilation

- **What It Is**: Compiling a program on one platform to run on another (e.g., building an ARM binary on an x86 system).
- **How It Works**: A cross-compiler generates code for a different architecture. For example:
  - Using GCC or Clang with a cross-compilation toolchain.
  - Configuring a CMake project to target a specific architecture.
- **Supported By**:
  - **GCC and Clang**: Widely used for cross-compilation.
  - **MinGW-w64**: For building Windows binaries on Linux.
  - **QEMU**: Often used for emulating the target architecture during testing.
- **Applications**:
  - **Embedded development**: Building for ARM microcontrollers or custom hardware.
  - **Mobile development**: Building apps for Android or iOS.
  - **Cross-platform software**: Compiling for Linux, Windows, macOS, etc.

### Dependency Management

- **What It Is**: Handling libraries or packages that your project depends on, ensuring they are available, up-to-date, and compatible.
- **Tools**:
  - **CMake** FetchContent: Directly downloads and integrates dependencies.
  - **vcpkg**: A package manager for C++.
  - **Conan**: A modern dependency manager for C++.
- **Importance**:
  - Avoids "dependency hell."
  - Streamlines the integration of third-party libraries.